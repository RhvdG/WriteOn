" Usage: :WriteOn <hesitation_seconds> <duration_minutes>
" Example: :WriteOn 10 5

" Force command definition to be global and overwrite existing ones
command! -nargs=+ -bang WriteOn call s:start_danger(<f-args>)
command! DangerStop call s:cleanup(bufnr('%'))

function! s:start_danger(hesitation, duration_mins) abort
  " CHECK 1: Must be an unsaved (unnamed) buffer
  " We use redraw to ensure the message appears even if Vim is busy
  if !empty(expand('%'))
    redraw
    echohl ErrorMsg
    echo "A NON-STARTER: You must use an unsaved (unnamed) buffer."
    echohl None
    return
  endif

  " CHECK 2: Must be completely empty
  if line('$') > 1 || getline(1) != ''
    redraw
    echohl ErrorMsg
    echo "A NON-STARTER: The buffer must be empty."
    echohl None
    return
  endif

  let b:danger_hesitation = str2nr(a:hesitation)
  let l:mins = str2nr(a:duration_mins)
  let b:danger_duration = l:mins * 60
  let b:danger_original_mins = l:mins 
  
  let b:danger_start_time = reltime()
  let b:danger_last_type = reltime()
  let b:danger_active = 1

  " LOCKDOWN: Set buffer type to 'nofile'
  setlocal buftype=nofile

  augroup DangerMode
    autocmd! * <buffer>
    autocmd TextChangedI <buffer> let b:danger_last_type = reltime()
    autocmd BufLeave <buffer> call s:cleanup(bufnr('%'))
    autocmd BufWriteCmd <buffer> call s:fail_on_save()
  augroup END

  let b:danger_timer = timer_start(1000, function('s:watchdog', [bufnr('%')]), {'repeat': -1})

  redraw
  echo "Keep writing!"
endfunction

function! s:fail_on_save() abort
  call s:cleanup(bufnr('%'))
  silent! %delete _
  
  let l:old_ul = &undolevels
  let &l:undolevels = -1
  let &l:undolevels = l:old_ul
  
  redraw
  echohl ErrorMsg
  echo "SAVING IS FORBIDDEN. Buffer wiped."
  echohl None
endfunction

function! s:watchdog(bufnr, timer_id) abort
  if !getbufvar(a:bufnr, 'danger_active', 0)
    call timer_stop(a:timer_id)
    return
  endif

  " CHECK HESITATION
  let l:last_type = getbufvar(a:bufnr, 'danger_last_type', [])
  if !empty(l:last_type)
    let l:gap = reltimefloat(reltime(l:last_type))
    let l:limit = getbufvar(a:bufnr, 'danger_hesitation', 5)

    if l:gap >= l:limit
      " --- FAILURE SEQUENCE ---
      call s:cleanup(a:bufnr)

      call feedkeys("\<C-\>\<C-n>", 'n')
      silent! %delete _

      let l:old_ul = &undolevels
      let &l:undolevels = -1
      let &l:undolevels = l:old_ul

      redraw
      echohl ErrorMsg
      echo "YOU HESITATED for " . printf('%.1f', l:gap) . "s. Buffer wiped."
      echohl None
      return
    endif
  endif

  " CHECK DURATION
  let l:start = getbufvar(a:bufnr, 'danger_start_time', [])
  if !empty(l:start)
    let l:elapsed = reltimefloat(reltime(l:start))
    let l:duration = getbufvar(a:bufnr, 'danger_duration', 300)

    if l:elapsed >= l:duration
      let l:mins = getbufvar(a:bufnr, 'danger_original_mins', 0)
      
      " UNLOCK
      setlocal buftype=
      
      call s:cleanup(a:bufnr)
      redraw
      echomsg "WELL DONE. You wrote for " . l:mins . " minute" . (l:mins == 1 ? "" : "s") . " non-stop."
    endif
  endif
endfunction

function! s:cleanup(bufnr) abort
  call setbufvar(a:bufnr, 'danger_active', 0)
  let l:tid = getbufvar(a:bufnr, 'danger_timer', -1)
  if l:tid != -1
    call timer_stop(l:tid)
    call setbufvar(a:bufnr, 'danger_timer', -1)
  endif
  if bufexists(a:bufnr)
    augroup DangerMode
      execute 'autocmd! * <buffer=' . a:bufnr . '>'
    augroup END
  endif
endfunction
